# About _between/3_

This is an examples companion page to the [`between/3`](https://eu.swi-prolog.org/pldoc/doc_for?object=between/3) page of the SWI-Prolog reference manual.

## Unit test code for _between/3_

Here is unit test code for `between/3`: 

**[`test_between.pl`](code/test_between.pl)**

... useful as "live documentation".

## No results in interval means (predictably) failure

```
?- 
between(0,0,X).
X = 0.

?- 
between(0,-1,X).
false.
```

## Creating lists of integers

This can be done directly with [`numlist/3`](https://eu.swi-prolog.org/pldoc/doc_for?object=numlist/3):

```
?- 
numlist(0,4,L).

L = [0, 1, 2, 3, 4].
```

Same as using `between/3` inside [`bagof/3`](https://eu.swi-prolog.org/pldoc/doc_for?object=bagof/3):

```
?- 
bagof(X,between(0,4,X),L).

L = [0, 1, 2, 3, 4].
```

Negative numbers are well accepted:

```
?- 
numlist(-4,4,L).

L = [-4, -3, -2, -1, 0, 1, 2, 3, 4].

?- 
bagof(X,between(-4,4,X),L).

L = [-4, -3, -2, -1, 0, 1, 2, 3, 4].
```

For "no solutions", we fail, as we should:

```
?- 
numlist(1,0,L).

false.

?- 
bagof(X,between(1,0,X),L).

false.

?- 
between(1,0,X).

false.
```

If you use [`findall/3`](https://eu.swi-prolog.org/pldoc/doc_for?object=findall/3) instead of
[`bagof/3`](https://eu.swi-prolog.org/pldoc/doc_for?object=bagof/3)
you get an empty list on "no solutions", which is pleasing
to our inner imperative programmer but not in the spirit of logic programming, so beware:

```
?- 
findall(X,between(1,0,X),L).

L = [].
```

## More uses of "between-in-bagof":

Here is one with a non-atomic goal:

```
?- 
bagof(K, (between(1,3,K),format("Hello ~d\n",[K])), Bag).

Hello 1
Hello 2
Hello 3
Bag = [1, 2, 3].
```

How to enumerate/generate cartesian coordinates (the last atomic goal iterates fastest).
Modify the value of flag `answer_write_options` to see the full result printed out instead of an elided result:

```
?- 
set_prolog_flag(answer_write_options,[max_depth(100)]).

?- 
bagof([X,Y], (between(1,3,X),between(44,46,Y)), Bag).

Bag = [[1,44],[1,45],[1,46],[2,44],[2,45],[2,46],[3,44],[3,45],[3,46]].
```

Create several lists with their lengths ranging between two numbers 
(and then bind their elements to random numbers for good measure, using 
[`maplist/2`](https://eu.swi-prolog.org/pldoc/doc_for?object=maplist/2))
We don't even give the `Bag` size, which is determined by the range generated by `between/3`.
Note that this works because both `List` and `Length` appear in the _Template_ argument
of `bagof/3` (the first argument). If `Length` did not appear there, one would have to
indicate that `Length` is a variable to be backtracked over internally, i.e. use a caret: `bagof( List, Length^( ...`

```
?- 
set_prolog_flag(answer_write_options,[max_depth(100)]).

?-
bagof( [Length,List], 
       (
          between(1,5,Length),
          length(List,Length),
          maplist([X]>>random_between(1000,9999,X),List)
       ),
       Bag).       

Bag = [[1,[3383]],
       [2,[8545,6141]],
       [3,[5543,5736,3552]],
       [4,[6630,8453,6741,7991]],
       [5,[3806,6829,7830,7317,1649]]].
```

If the goal to the right of `between/3` backtracks infinitely, 
you can use [library(solution_sequences)](https://eu.swi-prolog.org/pldoc/man?section=solutionsequences) 
to limit it. Here with [`limit/2`](https://eu.swi-prolog.org/pldoc/doc_for?object=limit/2):

```
?- 
bagof([X,Y],
      (
         between(1,5,X),
         limit(3,between(X,inf,Y))
      ),
      Bag). 
      
Bag = [[1,1],[1,2],[1,3],
       [2,2],[2,3],[2,4],
       [3,3],[3,4],[3,5],
       [4,4],[4,5],[4,6],
       [5,5],[5,6],[5,7]].
```

## Failure-driven loops using "between"

`between/3` can be used to implement limited "failure-driven loops" 
(unlike `repeat/0`, which redoes forever). It behaves like 
`member/2` over a [list comprehension](https://en.wikipedia.org/wiki/List_comprehension) indicated by the two integer arguments:

```
?- between(1,4,X), format("Hello ~d!\n",[X]), fail.
Hello 1!
Hello 2!
Hello 3!
Hello 4!
false.
```

## Extension of _between/3_: _between/4_ and _between/5_, a (correctly lazy) "between" which also takes the "step"

   - [Code](/code/heavycarbon/utils/between_with_step.pl) ([raw code](https://raw.githubusercontent.com/dtonhofer/prolog_notes/master/code/heavycarbon/utils/between_with_step.pl))
   - [Unit tests](/code/heavycarbon/utils/between_with_step.plt) ([raw code](https://raw.githubusercontent.com/dtonhofer/prolog_notes/master/code/heavycarbon/utils/between_with_step.plt))
   - New to modules? [TL;DR for installation](/code/heavycarbon/utils/TLDR_between_with_step.txt)

```
between(+Start,+End,+Step,?Value)
between(+Start,+End,+Step,?Value,?OptionList)
```

Examples for `between/4`:

```
?- 
between(10,20,3,L).

L = 10 ;
L = 13 ;
L = 16 ;
L = 19.

?- 
between(10,-10,-3,L).

L = 10 ;
L = 7 ;
L = 4 ;
L = 1 ;
L = -2 ;
L = -5 ;
L = -8.
```

Of course one could engineer something like

```
?- between(0,3,_X),L is 10+3*_X.
_X = 0,
L = 10 ;
_X = 1,
L = 13 ;
_X = 2,
L = 16 ;
_X = 3,
L = 19.
```

But why waste a good occasion to program?

## A symmetric _between/3_: _between_sym/3_

A naive symmetric between, which can generate increasing (step 1)
and decreasing (step -1) sequences. The "empty sequence", whereby
`between(A,B,X)` fails at once if `(B<A)`, no longer exists.

In the case of a decreasing sequence, this is done by generating 
the whole sequence and storing it. Catastrophic on large sequences!

The correct way to implement this is via lazy ("generate-on-demand") 
sequences - just keep a small state in an object and compute the 
next sequence member only when requested. In Prolog, the "object" 
is the stack frame and "when requested" is the backtracking "redo".
See `between/4` above.

```
% No need to check parameters; let between/3 do that
% between/3 throws if A,B not integers

between_sym(A,B,X) :-
   (A =< B)
   ->    
   between(A,B,X)
   ;
   (bagof(Q,between(B,A,Q),Seq),reverse(Seq,SeqR),member(X,SeqR)).
   
:- begin_tests(between_sym).

test(1, all(X = [1,2,3]))   :- between_sym(1,3,X).
test(2, all(X = [3,2,1]))   :- between_sym(3,1,X).
test(1, all(X = [-1,0,+1])) :- between_sym(-1,+1,X).
test(2, all(X = [+1,0,-1])) :- between_sym(+1,-1,X).
test(1, all(X = [0]))       :- between_sym(0,0,X).
test(1, throws(_))          :- between_sym(a,0,_).

:- end_tests(between_sym).
```
