## Cheatsheet

A cheatsheet for format/2 can be grabbed here:

   - [PDF](https://github.com/dtonhofer/prolog_notes/tree/master/swipl_notes/about_output_formatting/format_2_cheatsheet/format_2_cheatsheet.pdf)
   - [ODS](https://github.com/dtonhofer/prolog_notes/tree/master/swipl_notes/about_output_formatting/format_2_cheatsheet/format_2_cheatsheet.ods)
   - [PNG](https://github.com/dtonhofer/prolog_notes/tree/master/swipl_notes/about_output_formatting/format_2_cheatsheet/format_2_cheatsheet.png)

## More on various printing predicates

For those looking for the correct predicate to use:

   - [Relevant predicates for generating output in Prolog](https://github.com/dtonhofer/prolog_notes/blob/master/swipl_notes/about_output_formatting/README.md) - Notes (this is getting large)
   - [Relevant predicates for generating output in Prolog](https://github.com/dtonhofer/prolog_notes/blob/master/swipl_notes/about_output_formatting/output_formatting_pics/tldr.svg) - SVG overview diagram

## From the toolbox: Defensive programming around format calls

format/2 is **precise in the arguments it expects** and will throw if there are too many or too few arguments.

If you want to make sure a call to format/2 won't generate further exceptions in situations where you are already handling an exception for example here:

[`safe_format.pl`](https://github.com/dtonhofer/prolog_notes/blob/master/code/heavycarbon/support/safe_format.pl)

```
?- safe_format("Everything is going extremely ~s. We have ~s complaints",["well","no"],Text).
Text = "Everything is going extremely well. We have no complaints".

?- safe_format("Open the ~s.",["pod bay doors","HAL"],Text).
Text = "Exception in format/2. Args: <Open the ~s.> & <pod bay doors> & <HAL>".
```

## Justify text left, right or centered

You can use the format/2 tabstop markers directly and flexibly.

For example, a program that builds a format string to set tabstops and print "Hello" into that space, center-justified (with + used as whitespace on the left, * used as whitespace on the right):

```
several_strings :-
   Ch1=0'+,  % a codepoint
   Ch2=0'*,  % a codepoint
   bagof(X,between(0,20,X),Positions), % a list 0..20
   maplist(
       {Ch1,Ch2}/[P,F]>>
          atomics_to_string(["~|","~",Ch1,"t","~s","~",Ch2,"t","~",P,"+"],F),
       Positions,
       FormatStrings),
   maplist(
       [F]>>
         (format("The format string is ~q, The formatted string is ",[F]),
          format(F,["Hello"]),
          format("~n")),
       FormatStrings).
```

Sample output:

```
The format string is "~|~43t~s~42t~5+", The formatted string is Hello
The format string is "~|~43t~s~42t~6+", The formatted string is Hello*
The format string is "~|~43t~s~42t~7+", The formatted string is +Hello*
The format string is "~|~43t~s~42t~8+", The formatted string is +Hello**
The format string is "~|~43t~s~42t~9+", The formatted string is ++Hello**
The format string is "~|~43t~s~42t~10+", The formatted string is ++Hello***
```
   
Note that the tabstop position markers are all relative instead of absolute. This is needed because the absolute tabpositions are positions in the output line, not the string generated by "format" (so format seems to consult the status of the current line in `current_output`). As the intro "The format string ..." is of variable length, absolute positions relative to the line would not work and absolute positions relative to the string would be a swamped by a sufficently long intro.

Note that tabstop position 0 is after character 0, counted from 0 (as expected):

```
?- format("~42t~0|<\n"). % tabstop at 0, there are no characters to fill in with ~t
<

?- format("~42t~1|<\n"). % tabstop at 1, there is 1 characters to fill in with ~t
*<

?- format("~42t~2|<\n"). % tabstop at 2, there are 2 characters to fill in with ~t
**<
```

## From the toolbox: Justify text left, right or centered

I did my own code for "string justification" as programming exercise, this becomes complex quickly:

   - [justify.pl](https://github.com/dtonhofer/prolog_notes/blob/master/code/heavycarbon/strings/justify.pl)
   - [justify.plt](https://github.com/dtonhofer/prolog_notes/blob/master/code/heavycarbon/strings/justify.plt) (unit tests)

## Playing with floats

This little example prints a float, reads it back and compares:

Note that float are [IEEE 754 64-bit floats](https://en.wikipedia.org/wiki/IEEE_754), which have 53 binary digits, thus 15.95 decimal digits of precision between 1.0 and 2.0.

At a precision of 16 decimal digits, the difference to what is read back in is 0 (or rather, it underflows to 0?). 

Adding more precision makes the printer hallucinate meaningless additional digits of precision. Fun!

==
several_floats :-
   V is sqrt(2),
   assertion(float(V)),
   bagof(X,between(0,20,X),Positions), % a list 0..20
   maplist({V}/[P,F]>>atomics_to_string(["~",P,"e"],F),Positions,FormatStrings),
   maplist(
      {V}/[F]>>(
         format("The format string is ~q",[F]),
         format(string(FormyV),F,[V]),
         format(", The formatted string is ~s",[FormyV]),
         string_codes(FormyV,Cs),
         phrase(float(ReadV),Cs), 
         assertion(float(ReadV)),
         Delta is V-ReadV,
         format(", The difference to the read-back value is ~e",[Delta]),
         format("~n")),
      FormatStrings).
==      

==
The format string is "~13e", The formatted string is 1.4142135623731e+00, The difference to the read-back value is -4.884981e-15
The format string is "~14e", The formatted string is 1.41421356237310e+00, The difference to the read-back value is -4.884981e-15
The format string is "~15e", The formatted string is 1.414213562373095e+00, The difference to the read-back value is 2.220446e-16
The format string is "~16e", The formatted string is 1.4142135623730951e+00, The difference to the read-back value is 0.000000e+00
The format string is "~17e", The formatted string is 1.41421356237309515e+00, The difference to the read-back value is 0.000000e+00
The format string is "~18e", The formatted string is 1.414213562373095145e+00, The difference to the read-back value is 0.000000e+00
==

## Inline function call 

SWI-Prolog has [dicts](https://eu.swi-prolog.org/pldoc/man?section=bidicts). Predicates can be associated to those, and they behave like function calls. This gives us function calls beyond the arithmetic evaluation of is/2. In particular, for strings you can do things like this:

Define a module called =string= to associate functions to dicts with tag =string= (there is a problem in that modules are not hierarchical so you may end up with a name clash in the unique global module space, but, let's disregard this for now):

==
:- module(string,[]).

% This is a predicate format/3 written as a function format/2 (maybe there
% needs to be a new descriptor syntax: format///2 ?) taking a dict tagged as
% "string" and two arguments which evaluates to the value of variable Text.

S.format(Msg,Args) := Text :- with_output_to(string(Text),format(Msg,Args)).
==

Once the above module has been loaded, you can do things like these, which 
behave like a Java "static" method call (you can move args into the dict
too of course):

==
?- X=string{}.format("Hello, ~q\n",["World"]).
X = "Hello, \"World\"\n".
==

==
?- debug(foo),debug(foo,string{}.format("Hello, ~q\n",["World"]),[]).
% Hello, "World"
==

## More tricks

Generates a string of 2 spaces in `Spaces`: 

```
format(string(Spaces), '~t~*|', [2]).
```

   - because `~t` soaks up positions between the 0th and the 1st tab stop and generates space characters
   - `~*|` sets the next tab stop at the position given by the value in the arglist, i.e. at position 2.

## Related: Tabular data

I always wanted to print tabular data in Prolog. Here is a dirt simple way of doing it (still has rough edges, prerelesase):

   - [tablify.pl](https://github.com/dtonhofer/prolog_notes/blob/master/code/heavycarbon/strings/tablify.pl)

Prints things like these based on a table description made with a dict:

```
?- test_tablify(X).
+------+--------+------------+--------------+------------+------+
| Name | Prior  | Local cost | Overall cost |   State    | Hops |
+------+--------+------------+--------------+------------+------+
|  a   |        |        100 |      1000000 | visit_next |  100 |
|  b   | calpha |         10 |          100 |   probed   |  100 |
+------+--------+------------+--------------+------------+------+
```

## Related: Simple code to prettyprint a dict

If the values hold on one line...

[`prettyprint_dict.pl`](https://github.com/dtonhofer/prolog_notes/blob/master/code/snippets/prettyprint_dict.pl)
